<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0"
/>
<title>Retbro RetroPie Menu</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  :root{
    --retro-red:#d32f2f;
    --bg:#111;
    --panel:#1a1a1a;
    --panel-2:#222;
    --muted:#444;
    --text:#fff;
    --sub:#ccc;
  }

  *{ box-sizing:border-box }

  body{
    font-family:'Press Start 2P', system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    background:#111;
    color:var(--text);
    margin:0;
    overflow:hidden;
  }

  header{
    text-align:center;
    padding:18px 12px;
    font-size:1.25rem;
    letter-spacing:2px;
    background:var(--panel-2);
    border-bottom:4px solid var(--retro-red);
    color:var(--retro-red);
    user-select:none;
  }

  #fileInput{
    display:block;
    margin:16px auto 8px;
    padding:10px 14px;
    border-radius:8px;
    border:2px solid var(--retro-red);
    background:var(--panel-2);
    color:var(--text);
    cursor:pointer;
    font-family:inherit;
    font-size:.8rem;
  }
  #fileInput:hover{ background:var(--retro-red); color:#000 }

  #message{
    text-align:center;
    margin:4px 0 8px;
    font-size:.85rem;
    color:#f88;
    min-height:1.2em;
  }

  /* System carousel */
  #menu{
    display:flex;
    justify-content:center;
    align-items:center;
    gap:54px;
    padding:18px;
    height:58vh;
    overflow:hidden;
  }

  .system-tile{
    width:180px;
    height:180px;
    background:var(--panel);
    border:3px solid var(--muted);
    border-radius:12px;
    display:flex;
    justify-content:center;
    align-items:center;
    font-size:.9rem;
    text-align:center;
    padding:10px;
    color:#ccc;
    cursor:pointer;
    transition:transform .22s, border-color .22s, box-shadow .22s, color .22s;
    user-select:none;
  }
  .system-tile.selected,
  .system-tile:hover{
    transform:scale(1.22);
    border-color:var(--retro-red);
    box-shadow:0 0 28px var(--retro-red);
    color:#fff;
  }

  /* Overlay */
  #romOverlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.96);
    display:none;
    flex-direction:column;
    padding:18px;
    z-index:1000;
  }

  .overlay-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    margin-bottom:10px;
  }

  #overlaySystemName{
    color:var(--retro-red);
    font-size:1rem;
    margin:0 6px;
  }

  #searchInput{
    padding:8px 12px;
    font-family:inherit;
    font-size:.75rem;
    border:2px solid var(--muted);
    border-radius:8px;
    background:var(--panel-2);
    color:var(--text);
    width:320px;
  }

  #romContainer{
    display:grid;
    grid-template-columns: 1fr 1.1fr;
    gap:22px;
    height:calc(100vh - 120px);
  }

  /* ROM list */
  #romList{
    background:var(--panel);
    border:2px solid var(--muted);
    border-radius:12px;
    padding:12px;
    overflow:auto;
  }

  #romList button{
    width:100%;
    text-align:left;
    background:transparent;
    color:var(--text);
    border:2px solid transparent;
    border-radius:8px;
    padding:10px 12px;
    font-size:.78rem;
    font-family:inherit;
    cursor:pointer;
    transition:transform .15s, background .15s, border-color .15s, color .15s;
    margin-bottom:8px;
  }

  #romList button:hover,
  #romList button.selected{
    background:var(--retro-red);
    border-color:var(--retro-red);
    color:#000;
    transform:scale(1.02);
  }

  /* Detail panel */
  #romDetail{
    background:var(--panel);
    border:2px solid var(--muted);
    border-radius:12px;
    padding:14px;
    overflow:auto;
  }

  .detail-top{
    display:grid;
    grid-template-columns: 180px 1fr;
    gap:16px;
    align-items:start;
  }

  .cover{
    width:100%;
    max-width:180px;
    border-radius:10px;
    border:2px solid var(--muted);
    background:#000;
  }

  .title{
    margin:0 0 6px;
    font-size:1rem;
  }

  .meta{
    display:grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap:8px 18px;
    font-size:.7rem;
    color:var(--sub);
  }
  .meta b{ color:#eee }

  .desc{
    margin-top:12px;
    font-size:.75rem;
    line-height:1.35;
    color:#ddd;
    white-space:pre-wrap;
  }

  .shots{
    margin-top:14px;
    display:grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap:10px;
  }
  .shots img{
    width:100%;
    border-radius:8px;
    border:2px solid var(--muted);
    display:block;
  }

  .loading, .error{
    text-align:center;
    color:#aaa;
    font-size:.8rem;
    padding:16px 0;
  }
  .error{ color:#f88 }

  /* Helper: hide scrollbars while keeping scrollable (WebKit) */
  #romList::-webkit-scrollbar,
  #romDetail::-webkit-scrollbar{ width:10px }
  #romList::-webkit-scrollbar-thumb,
  #romDetail::-webkit-scrollbar-thumb{
    background:#333; border-radius:8px; border:2px solid #111;
  }

  footer {
    position: fixed;
    left: 0;
    bottom: 0;
    width: 100%;
    background-color: rgba(0, 0, 0, 0.464);
    color: white;
    text-align: center;
  }
</style>
</head>
<body>
  <header>RETBRO</header>
  <input type="file" id="fileInput" accept=".retbrorl,.json"  />
  <div id="message"></div>
  <div id="menu"></div>

  <!-- Overlay -->
  <div id="romOverlay" aria-hidden="true">
    <div class="overlay-header">
      <h2 id="overlaySystemName">SYSTEM</h2>
      <input id="searchInput" type="text" placeholder="Search ROMs..." />
    </div>

    <div id="romContainer">
      <div id="romList" role="listbox" aria-label="ROM list"></div>

      <div id="romDetail">
        <div class="loading">Select a game to see details…</div>
      </div>
    </div>
  </div>

  <footer>
    <a href="credits.txt">Credits</a> | <a href="https://docs.retbro.optb.qzz.io">Docs</a>
  </footer>

<script>
/* ---------- DOM ---------- */
const fileInput         = document.getElementById('fileInput');
const menuDiv           = document.getElementById('menu');
const messageDiv        = document.getElementById('message');
const romOverlay        = document.getElementById('romOverlay');
const overlaySystemName = document.getElementById('overlaySystemName');
const searchInput       = document.getElementById('searchInput');
const romListDiv        = document.getElementById('romList');
const romDetailDiv      = document.getElementById('romDetail');

/* ---------- State ---------- */
let systems = [];
let systemIndex = 0;

let romDataGlobal = {};
let roms = [];               // array of ROM urls (strings)
let romButtons = [];         // array of <button>
let romIndex = 0;            // selected index within romButtons
let metadataCache = new Map();

/* ---------- Utilities ---------- */
// decode %20 and remove extension
const decodeName = (s) => decodeURIComponent(s).replace(/\.[^/.]+$/, "");

// keep full display name (incl. region/rev), but simplify for lookup
const toLookupTitle = (name) =>
  name
    .replace(/\[[^\]]*\]/g, "")    // [!], [Proto], etc
    .replace(/\s*\([^)]*\)/g, "")  // (USA), (Rev 1), etc
    .replace(/\s+/g, " ")
    .trim();

// get last segment of path
const basename = (p) => p.split("/").pop();

// Convenience: create element
function el(tag, props={}, ...children){
  const e = document.createElement(tag);
  Object.assign(e, props);
  for(const c of children){
    if (c == null) continue;
    e.append(typeof c === "string" ? document.createTextNode(c) : c);
  }
  return e;
}

/* ---------- File load ---------- */
fileInput.addEventListener('change', async (ev) => {
  const file = ev.target.files[0];
  if (!file) return;

  if (!/\.retbrorl$|\.json$/i.test(file.name)){
    messageDiv.textContent = "Please select a valid .retbrorl or .json file.";
    return;
  }

  try{
    const text = await file.text();
    romDataGlobal = JSON.parse(text);

    systems = Object.keys(romDataGlobal);
    if(!systems.length){
      messageDiv.textContent = "No ROMs found in the file.";
      return;
    }

    messageDiv.textContent = "← → (or D-pad left/right) to choose a system, Enter/A to open.";
    menuDiv.innerHTML = "";
    systems.forEach((sys, i) => {
      const tile = el("div", { className:"system-tile", textContent: sys });
      tile.addEventListener('click', () => { systemIndex = i; updateSystemSelection(); openRomOverlay(); });
      tile.addEventListener('mouseenter', () => { systemIndex = i; updateSystemSelection(); });
      menuDiv.appendChild(tile);
    });
    updateSystemSelection();
  }catch(err){
    console.error(err);
    messageDiv.textContent = "Could not read or parse the JSON file.";
  }
});

/* ---------- System carousel selection ---------- */
function updateSystemSelection(){
  const tiles = document.querySelectorAll('.system-tile');
  tiles.forEach(t => t.classList.remove('selected'));
  if (tiles[systemIndex]){
    tiles[systemIndex].classList.add('selected');
    tiles[systemIndex].scrollIntoView({ behavior:"smooth", inline:"center", block:"nearest" });
  }
}

/* ---------- Overlay ---------- */
function openRomOverlay(){
  const systemName = systems[systemIndex];
  overlaySystemName.textContent = systemName;

  roms = romDataGlobal[systemName] || [];
  romListDiv.innerHTML = "";
  romDetailDiv.innerHTML = '<div class="loading">Select a game to see details…</div>';
  metadataCache.clear(); // optional: clear when switching systems

  romButtons = roms.map((url, idx) => {
    const raw   = basename(url);
    const shown = decodeName(raw);     // keep (Japan) (Rev 1) visible
    const btn   = el("button", { textContent: shown });
    btn.dataset.idx = idx;
    btn.dataset.url = url;
    btn.addEventListener('click', () => launchRomByUrl(url));
    btn.addEventListener('mouseenter', () => { romIndex = idx; highlightRomAndShowDetails(); });
    romListDiv.appendChild(btn);
    return btn;
  });

  romIndex = 0;
  highlightRomAndShowDetails();

  romOverlay.style.display = "flex";
  romOverlay.setAttribute("aria-hidden","false");
  searchInput.value = "";
  searchInput.focus({ preventScroll:true });
}

/* ---------- Detailed view ---------- */
async function highlightRomAndShowDetails(){
  // sync selection with visible items only
  const visible = romButtons.filter(b => b.style.display !== "none");
  if (!visible.length){ romDetailDiv.innerHTML = '<div class="error">No results.</div>'; return; }

  // clamp romIndex to a visible element
  const target = visible[Math.min(romIndex, visible.length-1)];
  romButtons.forEach(b => b.classList.remove("selected"));
  target.classList.add("selected");

  // display loading
  romDetailDiv.innerHTML = '<div class="loading">Fetching game info…</div>';

  const displayName = target.textContent;
  const cacheKey = displayName;
  let info = metadataCache.get(cacheKey);
  if (!info){
    info = await fetchGameInfo(displayName);
    metadataCache.set(cacheKey, info);
  }

  renderDetail(info);
}

function renderDetail(info){
  const cover = info.cover || `https://picsum.photos/300/420?random=${encodeURIComponent(info.name)}`;
  const shots = info.screenshots || [];
  const genresJoined = info.genres?.length ? info.genres.join(", ") : (info.genre || "Unknown");

  romDetailDiv.innerHTML = "";
  const top = el("div", { className:"detail-top" },
    el("img", { className:"cover", src: cover, alt:"cover" }),
    el("div", {},
      el("h3", { className:"title", textContent: info.name || "Unknown Title" }),
      el("div", { className:"meta" },
        el("div", {}, el("b", {}, "System: "),     " ", info.system || "Unknown"),
        el("div", {}, el("b", {}, "Genre: "),      " ", genresJoined),
        el("div", {}, el("b", {}, "Developer: "),  " ", info.dev || "Unknown"),
        el("div", {}, el("b", {}, "Publisher: "),  " ", info.publisher || "Unknown"),
        el("div", {}, el("b", {}, "Players: "),    " ", info.players || "Unknown"),
        el("div", {}, el("b", {}, "Year: "),       " ", info.year || "Unknown"),
      )
    )
  );

  const desc = el("div", { className:"desc" }, info.desc || "No description available.");
  romDetailDiv.append(top, desc);

  if (shots.length){
    const grid = el("div", { className:"shots" });
    shots.slice(0, 8).forEach(src => grid.appendChild(el("img", { src, alt:"screenshot" })));
    romDetailDiv.appendChild(grid);
  }
}

/* ---------- Search/filter ---------- */
searchInput.addEventListener('input', () => {
  const q = searchInput.value.trim().toLowerCase();
  romButtons.forEach(btn => {
    const hit = btn.textContent.toLowerCase().includes(q);
    btn.style.display = hit ? "" : "none";
  });
  // reset selection to the first visible
  romIndex = 0;
  highlightRomAndShowDetails();
});

/* ---------- Launch ---------- */
function launchRomByUrl(url){
  window.location.href = `emulator.html?rom=${encodeURIComponent(url)}`;
}

/* ---------- Keyboard ---------- */
document.addEventListener('keydown', (e) => {
  // overlay open?
  const overlayOpen = romOverlay.style.display === "flex";
  if (overlayOpen){
    if (e.key === "ArrowDown"){ moveSelection(1); }
    else if (e.key === "ArrowUp"){ moveSelection(-1); }
    else if (e.key === "Enter"){ const sel = getSelectedVisible(); if(sel) launchRomByUrl(sel.dataset.url); }
    else if (e.key === "Escape"){ closeOverlay(); }
  }else{
    if (e.key === "ArrowRight"){ systemIndex = (systemIndex + 1) % systems.length; updateSystemSelection(); }
    else if (e.key === "ArrowLeft"){ systemIndex = (systemIndex - 1 + systems.length) % systems.length; updateSystemSelection(); }
    else if (e.key === "Enter"){ openRomOverlay(); }
  }
});

function getVisibleButtons(){
  return romButtons.filter(b => b.style.display !== "none");
}
function getSelectedVisible(){
  const visible = getVisibleButtons();
  return visible[Math.min(romIndex, visible.length-1)];
}
function moveSelection(delta){
  const visible = getVisibleButtons();
  if (!visible.length) return;
  romIndex = (Math.min(romIndex, visible.length-1) + delta + visible.length) % visible.length;
  highlightRomAndShowDetails();
}
function closeOverlay(){
  romOverlay.style.display = "none";
  romOverlay.setAttribute("aria-hidden","true");
  searchInput.blur();
}

/* ---------- Controller (Gamepad API) ---------- */
let gpIndex = null;
let lastAxis = { x:0, y:0 };
let lastMoveTime = 0;
const AXIS_DEADZONE = 0.45;
const REPEAT_DELAY_MS = 160;

window.addEventListener("gamepadconnected", e => { gpIndex = e.gamepad.index; });
window.addEventListener("gamepaddisconnected", () => { gpIndex = null; });

function pollGamepad(){
  if (gpIndex !== null){
    const gp = navigator.getGamepads()[gpIndex];
    if (gp){
      // Buttons
      const A = gp.buttons[0]?.pressed;     // A / Cross
      const B = gp.buttons[1]?.pressed;     // B / Circle
      const START = gp.buttons[9]?.pressed; // Start/Options

      const now = performance.now();

      // Axes (left stick)
      const ax = gp.axes[0] || 0;
      const ay = gp.axes[1] || 0;

      const overlayOpen = romOverlay.style.display === "flex";

      // debounce axis: only trigger when crossing deadzone + small repeat delay
      function axisTrigger(dir, prev, cur){
        return (Math.sign(cur) === dir && Math.abs(cur) > AXIS_DEADZONE && (Math.sign(prev) !== dir || Math.abs(prev) <= AXIS_DEADZONE) )
                || (Math.sign(cur) === dir && Math.abs(cur) > AXIS_DEADZONE && now - lastMoveTime > REPEAT_DELAY_MS);
      }

      if (axisTrigger(-1, lastAxis.x, ax)){ // left
        if (!overlayOpen){ systemIndex = (systemIndex - 1 + systems.length) % systems.length; updateSystemSelection(); }
        lastMoveTime = now;
      }
      if (axisTrigger( 1, lastAxis.x, ax)){ // right
        if (!overlayOpen){ systemIndex = (systemIndex + 1) % systems.length; updateSystemSelection(); }
        lastMoveTime = now;
      }
      if (axisTrigger(-1, lastAxis.y, ay)){ // up
        if (overlayOpen) moveSelection(-1);
        lastMoveTime = now;
      }
      if (axisTrigger( 1, lastAxis.y, ay)){ // down
        if (overlayOpen) moveSelection(1);
        lastMoveTime = now;
      }

      lastAxis = { x: ax, y: ay };

      // Buttons map
      if (A){ // select / open
        if (overlayOpen){
          const sel = getSelectedVisible();
          if (sel) launchRomByUrl(sel.dataset.url);
        }else{
          openRomOverlay();
        }
      }
      if (B){ // back
        if (overlayOpen) closeOverlay();
      }
      if (START && !overlayOpen){
        openRomOverlay();
      }
    }
  }
  requestAnimationFrame(pollGamepad);
}
pollGamepad();

/* ---------- ScreenScraper API (no key) + Picsum fallback ---------- */
async function fetchGameInfo(displayName){
  // Build a smart lookup title to improve matches
  const cleanDisplay = decodeName(displayName);
  const lookup = toLookupTitle(cleanDisplay);

  // Compose URL with demo creds (public)
  const url = `https://www.screenscraper.fr/api2/jeuInfos.php?devid=demo&devpassword=demo&softname=demo&output=json&romnom=${encodeURIComponent(lookup)}`;

  try{
    const res = await fetch(url, { method:"GET" });
    // If CORS blocks or network fails, fall through to catch
    const json = await res.json();

    // The API may return an object or array; normalize:
    let game = json?.response?.jeu;
    if (Array.isArray(game)) game = game[0];

    if (!game) throw new Error("No game data");

    // medias can be 'medias' (array) or 'media' (array/object)
    let medias = game.medias ?? game.media ?? [];
    if (!Array.isArray(medias) && medias) medias = [medias];

    const getMediaUrl = (types) => {
      if (!Array.isArray(medias)) return "";
      const found = medias.find(m =>
        typeof m?.type === "string" &&
        types.some(t => m.type.toLowerCase().includes(t))
      );
      return found?.url || "";
    };

    const cover =
      getMediaUrl(["box-2d","box","boxart","cover","2d"]) ||
      `https://picsum.photos/300/420?random=${encodeURIComponent(lookup)}`;

    // screenshots: try a few common tags
    const shots = (Array.isArray(medias) ? medias : [])
      .filter(m => typeof m?.type === "string" && /screen|screenshot|title|in-game|ingame/.test(m.type.toLowerCase()))
      .map(m => m.url)
      .filter(Boolean);

    // genres can be array of objects or a string
    let genres = [];
    if (Array.isArray(game.genres)) {
      genres = game.genres.map(g => g?.nom || g?.name).filter(Boolean);
    } else if (typeof game.genre === "string") {
      genres = [game.genre];
    }

    const info = {
      name: game.nom || cleanDisplay,
      desc: game.synopsis || game.overview || "No description available.",
      cover,
      screenshots: shots,
      system: game.systeme?.nom || game.system?.name || "",
      genres,
      genre: genres[0] || "",
      dev: game.developpeur?.nom || game.developer?.name || "",
      publisher: game.editeur?.nom || game.publisher?.name || "",
      players: game.joueurs?.text || game.players || "",
      year: game.annee || game.year || ""
    };

    // Fill unknowns with sane defaults
    for (const k of ["system","dev","publisher","players","year"]){
      if (!info[k]) info[k] = "Unknown";
    }
    if (!info.genres?.length && !info.genre) info.genre = "Unknown";

    return info;

  }catch(err){
    console.warn("ScreenScraper lookup failed:", err);
    // Fallback
    return {
      name: cleanDisplay,
      desc: "No info found.",
      cover: `https://picsum.photos/300/420?random=${encodeURIComponent(lookup)}`,
      screenshots: [],
      system: "Unknown",
      genres: [],
      genre: "Unknown",
      dev: "Unknown",
      publisher: "Unknown",
      players: "Unknown",
      year: "Unknown"
    };
  }
}
</script>
</body>
</html>
